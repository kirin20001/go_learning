# Mutex常见的4种错误场景

- Mutex使用起来非常简洁
- 正常使用Mutex时存在一些常见的错误场景

## Lock/UnLock不是成对出现

- Lock/UnLock没有成对出现，就意味着会出现死锁的情况，
  - 代码中有太多的 if-else 分支，可能在某个分支中漏写了 Unlock；
  - 在重构的时候把 Unlock 给删除了；
  - Unlock 误写成了 Lock。
- 或者是因为 Unlock 一个未加锁的 Mutex 而导致 panic。

## Copy已使用的Mutex

- package sync的同步原语在使用后是不能复制的
- 原因：Mutex是一个有状态的对象，并发环境下，你根本不知道要复制的 Mutex 状态是什么，因为要复制的 Mutex 是由其它 goroutine 并发访问的，状态可能总是在变化。

### 死锁检查机制

- 通过copylock分析器静态分析函数调用、range遍历、复制、申明、函数返回值等位置，有没有锁的值copy的情况

### 重入

- 可重入锁：当一个线程获取锁时，如果没有其它线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时候也叫做递归锁）。只要你拥有这把锁，你可以可着劲儿地调用，比如通过递归实现一些算法，调用者不会阻塞或者死锁。
- Mutex不是可重入锁

### 实现可重入锁

#### 方案一 goroutineid

- runtime.Stack 方法、hacker方法、petermattis/goid等获取栈帧信息
- 见代码RecursiveMutex

方案二 token

- 调用者自己提供一个 token，获取锁的时候把这个 token 传入，释放锁的时候也需要把这个 token 传入。通过用户传入的 token 替换方案一中 goroutine id，其它逻辑和方案一一致。

### 死锁

- 两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。
- 互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。
- 持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。
- 不可剥夺：资源只能由持有它的 goroutine 来释放。
- 环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。
- 死锁检测：