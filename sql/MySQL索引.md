### MySQL 数据类型
#### 整数类型
- TINYINT 1字节
- SMALLINT 2字节
- MEDIUMINT 3字节
- INT（INTEGER）4字节
- BIGINT 8字节

#### 浮点数类型

- FLOAT 4字节
- DOUBLE 8字节

无符号类型

- UNSIGNED

字符串类型

- CHAR(M) 最大长度M个字符 固定长度字符串
- VARCHAR(M) 最大长度M个字符 可变长度字符串
- TINYTEXT 
- TEXT
- MEDIUMTEXT
- LONGTEXT

日期时间类型

二进制类型

### 表的基本操作

```mysql
CREATE TABLE [IF NOT EXISTS] table_name (
   column_name data_type [NOT NULL | NULL] [DEFAULT expr],
   column_name data_type [NOT NULL | NULL] [DEFAULT expr],
   ...,
   [table_constraints]
) [ENGINE=storage_engine];

```

- `CREATE TABLE` 语句创建一个给定名字 `table_name` 的表。

  - 表名可由字母、数字、下划线和美元符号组成，表名长度在 64 个字符以内。
  - 表名在一个数据库中是唯一的。
  - 新建的表会在当前默认的数据库中。如果还没有选择数据库，请使用 `db_name.table_name` 格式指定要新建的表所在的数据库。

- `IF NOT EXISTS` 指示只有给定的表不存在的时候才进行创建。它是可选的。

  如果你给定一个已经存在的表名，又没有使用 `IF NOT EXISTS` 子句，服务器会返回一个错误。

- `column_name data_type [NOT NULL | NULL] [DEFAULT expr] [AUTO_INCREMENT]` 定义了表中的一列。多个列使用逗号分隔。

  - `column_name` 是列的名字。列名可由字母、数字、下划线和美元符号组成，列名长度在 64 个字符以内。列名在一个表中是唯一的。
  - `data_type` 是数据类型，可以是 [CHAR](https://www.sjkjc.com/mysql/char/), [VARCHAR](https://www.sjkjc.com/mysql/varchar/), [INT](https://www.sjkjc.com/mysql/int/), [DATE](https://www.sjkjc.com/mysql/date/), [DATETIME](https://www.sjkjc.com/mysql/datetime/), [BIT](https://www.sjkjc.com/mysql/bit/), TEXT, [ENUM](https://www.sjkjc.com/mysql/enum/), JSON, BOLB 等。
  - `[NOT NULL | NULL]` 指示该列是否可以为 `NULL`。它是可选的。如果不指定该选项，则此列可以为 `NULL`。如果设置为 `NOT NULL`，则插入新行时该列必须有值。
  - `[DEFAULT expr]` 指示该列的默认值。它是可选的。如果不指定该选项，则此列的默认是 `NULL`。
  - `[AUTO_INCREMENT]` 指示该列是否是一个自增列。如果使用了此选项，则该列的值可有服务器自动产生和填充。该列的值从 `1` 开始，每增加一个行就会加 `1`。一个表中只能有一个自增列。

- `[table_constraints]` 位于列定义之后，它定义了表的约束。它是可选的。表的约束有[主键](https://www.sjkjc.com/mysql/primary-key/)、[外键](https://www.sjkjc.com/mysql/foreign-key/)、[CHECK](https://www.sjkjc.com/mysql/check-constraint/)、UNIQUE 等。

- `ENGINE=storage_engine` 子句指定了表使用的存储引擎。它是可选的。

  如果不指定此选项，则采用服务器默认的存储引擎。自 MySQL 5.5 版以来，服务器默认的引擎是由 MyISAM 变成了 InnoDB。

- 当表名或者字段名中含有空格或者其他特殊字字符时，请使用 ``` 包围起来。比如： ``test 1``。

E.g.

```mysql
CREATE TABLE table_name (
	number INT,
	name VARCHAR(5),
	
)
```



## InnoDB

### InnoDB简介
- InnoDB是将表中的数据存储懂啊磁盘上的存储引擎
- 读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我们想从表中获取某些记录时
- InnoDB存储引擎不需要一条一条的把记录从磁盘上读取出来
- 而是将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB内容刷新到磁盘中。

### InnoDB行格式
- 我们平时是以记录为单位来向表中插入数据的，这些记录在磁盘上的存放方式也被称为行格式或者记录格式。
```mysql
CREATE TABLE 表名 (列的信息) ROW_FORMAT=行格式名称
    
ALTER TABLE 表名 ROW_FORMAT=行格式名称
```

```mysql
CREATE TABLE record_format_demo (
	c1 VARCHAR(10),
	c2 VARCHAR(10) NOT NULL,
	c3 CHAR(10),
	c4 VARCHAR(10)
) CHARSET=ascii ROW_FORMAT=COMPACT;
```

- COMPACT 行格式
- Redundant行格式
- Dynamic和Compressed行格式

### 行溢出数据

- 一个页一般是`16KB`，当记录中的数据太多，当前页放不下的时候，会把多余的数据存储到其他页中，这种现象称为`行溢出`。

### InnoDB数据页结构

- `页`它是`InnoDB`管理存储空间的基本单位，一个页的大小一般是`16KB`
- InnoDB为了不同的目的而设计了不同类型的页，我们把用于存放记录的页叫做`索引页`
- 一个数据页可以被大致划分为7个部分，分别是
  - `File Header`，表示页的一些通用信息，占固定的38字节。
  - `Page Header`，表示数据页专有的一些信息，占固定的56个字节。
  - `Infimum + Supremum`，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的`26`个字节。
  - `User Records`：真实存储我们插入的记录的部分，大小不固定。
  - `Free Space`：页中尚未使用的部分，大小不确定。
  - `Page Directory`：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。
  - `File Trailer`：用于检验页是否完整的部分，占用固定的8个字节。
- 每个记录的头信息中都有一个`next_record`属性，从而使页中的所有记录串联成一个`单链表`。
- `InnoDB`会把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`，存放在`Page Directory`中，所以在一个页中根据主键查找记录是非常快的，分为两步：
  - 通过二分法确定该记录所在的槽。
  - 通过记录的next_record属性遍历该槽所在的组中的各个记录。
- 每个数据页的`File Header`部分都有上一个和下一个页的编号，所以所有的数据页会组成一个`双链表`。
- 为保证从内存中同步到磁盘的页的完整性，在页的首部和尾部都会存储页中数据的校验和和页面最后修改时对应的`LSN`值，如果首部和尾部的校验和和`LSN`值校验不成功的话，就说明同步过程出现了问题。
- 所以在一个数据页中查找指定主键值的记录的过程分为两步：
  1. 通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。
  2. 通过记录的`next_record`属性遍历该槽所在的组中的各个记录。

### B+树索引

- ### 没有索引时查找

  - 以主键为搜索条件: 在`页目录`中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录。
  - 以其他列作为搜索条件: 从`最小记录`开始依次遍历单链表中的每条记录，然后对比每条记录是不是符合搜索条件。很显然，这种查找的效率是非常低的。

- ### B+树索引

  - `InnoDB`是使用页来作为管理存储空间的基本单位
  - 使用目录项记录管理所有`目录项`
  - 实际用户记录其实都存放在B+树的最底层的节点上，这些节点也被称为`叶子节点`或`叶节点`
  - 用来存放`目录项`的节点称为`非叶子节点`或者`内节点`
  - B+树的非叶子结点不存放数据，适合储存在内存中，提高查询性能

- ### 聚簇索引

  - 如果索引叶子结点储存的是是数据行，那么就是聚簇索引。否则为非聚簇索引。
  - 使用记录主键值的大小进行记录和页的排序，这包括三个方面的含义：
    - 页内的记录是按照主键的大小顺序排成一个单向链表。
    - 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
  - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。

- ### 二级索引

  - 聚簇索引只能用于搜索条件为主键，

  - 针对非主键的索引可以建立二级索引

  - E.g.

    ```mysql
    CREATE TABLE index_demo(
      c1 INT,
    	c2 INT,
      c3 CHAR(1),
      PRIMARY KEY(c1)
    ) ROW_FORMAT = Compact;
    ```

    - 用c2列的大小作为数据页、页中记录的排序规则，再建一棵`B+`树：

      - 页内的记录是按照`c2`列的大小顺序排成一个单向链表。

      - 各个存放用户记录的页也是根据页中记录的`c2`列大小顺序排成一个双向链表。

      - 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的`c2`列大小顺序排成一个双向链表。

    - `B+`树的叶子节点存储的并不是完整的用户记录，而只是`c2列+主键`这两个列的值。

    - 目录项记录中不再是`主键+页号`的搭配，而变成了`c2列+页号`的搭配

  - 通过c2进行记录查询时可以使用该B+树的索引，流程如下：

    - 确定`目录项记录`页
    - 通过`目录项记录`页确定用户记录真实所在的页。
    - 在真实存储用户记录的页中定位到具体的记录。
    - 但是这个`B+`树的叶子节点中的记录只存储了`c2`和`c1`（也就是`主键`）两个列，所以我们必须再根据主键值去**聚簇索引**中再查找一遍完整的用户记录。这个过程也被称为`回表`。
    - 回表：
      - 在二级索引的叶子节点只记录建立索引列的值和主键的值，而不是直接存住完整的用户记录
      - 可以节省空间

  - ### 联合索引

    - 同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，本质上也是一个二级索引
    - E.g. 按照`c2`和`c3`列的大小进行排序
      - 先把各个记录和页按照`c2`列进行排序。
      - 在记录的`c2`列相同的情况下，采用`c3`列进行排序
      - 每条`目录项记录`都由`c2`、`c3`、`页号`这三个部分组成
      - `B+`树叶子节点处的用户记录由`c2`、`c3`和主键`c1`列组成。

  - ### 索引的代价

    - 占用存储空间
    - 每次对表中的数据进行增、删、改操作时，都需要去修改各个`B+`树索引。因为用户记录和目录项记录，都是按照索引列的值从小到大的顺序而形成了一个单向链表；每层B+树的节点是由小到大排列的双向列表。每次增删改都需要维护结点和记录，可能会造成时间上的损耗

  - ### 覆盖索引

    - 回表过程中需要会使用到两个`B+`树索引，一个二级索引，一个聚簇索引。

    - 访问二级索引使用`顺序I/O`，访问聚簇索引使用`随机I/O`。

    - 顺序I/O比随机I/O的性能高很多

    - 因此查询优化器会事先对表中的记录计算一些统计数据，然后再利用这些统计数据根据查询的条件来计算一下需要回表的记录数，需要回表的记录数越多，就越倾向于使用全表扫描，反之倾向于使用`二级索引 + 回表`的方式。（回表的记录越少，性能提升就越高）

    - 或者使用覆盖索引

      - 即在查询列表里只包含索引列，而不是查询列表为`*`

      - 如果业务需要查询出索引以外的列，那还是以保证业务需求为重。但是我们很不鼓励用`*`号作为查询列表，最好把我们需要查询的列依次标明。

      - e.g.

        ```mysql
        /*对name, birthday, phone_number建立索引 */
        CREATE TABLE person_info(
            id INT NOT NULL auto_increment,
            name VARCHAR(100) NOT NULL,
            birthday DATE NOT NULL,
            phone_number CHAR(11) NOT NULL,
            country varchar(100) NOT NULL,
            PRIMARY KEY (id),
            KEY idx_name_birthday_phone_number (name, birthday, phone_number)
        );
        
        /*查询列包含完整信息，回表查询数量为完整列表，倾向全表扫描 */
        SELECT * FROM person_info ORDER BY name, birthday, phone_number;
        
        /*对查询数量进行限制，倾向回表查询*/
        SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;
        
        /*查询列表里只包含索引列，不需要回表查询*/
        SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'
        
        ```

## 索引的应用场景

- 全值匹配

- 匹配左边的列

  - 搜索条件中的各个列必须是联合索引中从最左边连续的列。

- 匹配列的前缀

  - ```mysql
    SELECT * FROM person_info WHERE name LIKE 'As%';
    
    /*只给出后缀或者中间的某个字符串，只能全表扫描了*/
    SELECT * FROM person_info WHERE name LIKE '%As%';
    ```

  - 后缀查询时也可以把表中的数据逆序储存，然后建立索引。

- 匹配范围值

  - 不过在使用联合进行范围查找的时候需要注意，如果对多个列同时进行范围查找的话，只有对索引最左边的那个列进行范围查找的时候才能用到`B+`树索引。

- 精确匹配某一列并范围匹配另外一列

- 用于排序

  - ORDER BY

## 如何挑选索引

- 只为用于搜索、排序或分组的列创建索引

- 考虑列的基数
  - 最好为那些列的基数大的列建立索引，为基数太小列的建立索引效果可能不好。
  
- 索引列的类型尽量小

- 索引字符串值的前缀
	- `B+`树索引中的记录需要把该列的完整字符串存储起来，而且字符串越长，在索引中占用的存储空间越大。
	
	- 如果`B+`树索引中索引列存储的字符串很长，那在做字符串比较时会占用更多的时间。
	
	- 解决方案
	
	  - 只对字符串的前几个字符进行索引也就是说在二级索引的记录中只保留字符串前几个字符。
	
	  - e.g. `name(10)`就表示在建立的`B+`树索引中只保留记录的前`10`个字符的编码，这种只索引字符串值的前缀的策略是我们非常鼓励的，尤其是在字符串类型能存储的字符比较多的时候。
	
	    ```mysql
	    CREATE TABLE person_info(
	        name VARCHAR(100) NOT NULL,
	        birthday DATE NOT NULL,
	        phone_number CHAR(11) NOT NULL,
	        country varchar(100) NOT NULL,
	        KEY idx_name_birthday_phone_number (name(10), birthday, phone_number)
	    );    
	    ```
	
	- 影响：
	
	  - 二级索引中不包含完整的`name`列信息，所以无法对前十个字符相同，后边的字符不同的记录进行排序，也就是使用索引列前缀的方式无法支持使用索引排序
	  - 使用文件排序：把记录都加载到内存中，再用一些排序算法在内存中对这些记录进行排序，排序操作完成后再把排好序的结果集返回到客户端。（通常情况下ORDER BY就需要使用文件排序）

### 面试准备

- ### 判断是否回使用索引

  1. 不用包含全部联合索引中的列的场景，最左匹配原则，不符合原则的匹配无法使用索引
  2. `WHERE`子句中的几个搜索条件的顺序不会影响索引的使用
  3. 前缀匹配可以使用索引，中值后值匹配不能使用索引
  4. 范围查找只有首个查询值同时符合最右匹配的支持使用索引
  5. 使用联合索引用于分组，`ORDER BY`的子句后边的列的顺序也必须按照索引列的顺序给出，否则无法使用索引
  6. 联合索引的各个排序列的排序顺序必须是一致的ASC和DESC混用不支持索引
  7. 排序列包含非同一个索引的列不能使用索引
  8. 排序使用了复杂的表达式包括数学运算和函数调用不支持使用索引
  9. 数据量小，全表扫描反而更快
  10. 查询优化器：如果需要回表，而且回表查询数量越多，则倾向于全局扫描；查询条件过滤效果不好
  11. 使用了！= LIKE之类的查询
  12. 字段区分度不大。比如索引列中只有0和1，可能不用索引

- ### B+树优点

  1. mysql索引主要使用B+树：查询性能好，更稳定
  2. B+ & 平衡二叉树、红黑树均为二分的查找树，在同等数据量下高度更高，性能更差，还需要反复再平衡
  3. B+ & B树是平衡多路查找树，相比二叉树高度更低。但是数据存储在全部节点中，对范围查找不友好；非叶子节点也存储了数据，导致索引占用内存大，需要放在磁盘中，性能较差。

- ### 索引与NULL

	1.  MySQL可以在含有null的列上使用索引
	1.  `null`是一个特殊的值
	1.  不能使用`=,<,>`这样的运算符，对`null`做算术运算的结果都是`null`，`count`时不会包括`null`行等，某列可为null比not null可能需要更多的存储空间
