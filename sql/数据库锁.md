### 事务

- 事务需要遵循4个特性AICD

  - 原子性
    - `单个事务，为一个不可分割的最小工作单元`，整个事务中的所有操作要么全部commit成功，要么全部失败rollback，对于一个事务来说，不可能只执行其中的一部分SQL操作，这就是事务的原子性。
  - 隔离性
    - 其它事务对数据的修改不会影响当前事务的处理，这个规则被称之为`隔离性`。
    - 使用不动隔离级别保证事务的隔离性和性能间的平衡
  - 一致性
    - 数据的一致性
  - 持久性
    - 数据修改的结构将永久的保留

- 事务的状态

  - ![](/Users/wyl/Desktop/go/src/go_learning/sql/img/169d7fd5bd4ce2f1~tplv-t2oaga2asx-jj-mark-3024-0-0-0-q75.png)

- 事务语法

  ```mysql
  # 开启事务
  BEGIN; # 代表开启一个事务
  START TRANSACTION; # 同样标志着开启一个事务
  START TRANSACTION READ ONLY; # 只读事务
  START TRANSACTION READ WRITE; # 读写事务
  START TRANSACTION READ WRITE, WITH CONSISTENT SNAPSHOT # 启动一致性读
  
  SELECT ... # 事务中的一条语句
  UPDATE ... # 事务中的一条语句
  ... # 事务中的其它语句
  
  COMMIT; # 提交事务
  
  ROLLBACK； # 终止事务
  ```

  ### 事务并发执行遇到的问题

  - 脏写
    - 如果一个事务修改了另一个未提交事务修改过的数据，那就意味着发生了`脏写`
  - 脏读
    - 如果一个事务读到了另一个未提交事务修改过的数据，那就意味着发生了`脏读`
  - 不可重复读
    - 如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那就意味着发生了`不可重复读`
  - 幻读
    - 如果一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录，原先的事务再次按照该条件查询时，能把另一个事务插入的记录也读出来，那就意味着发生了`幻读`

  ### 四种隔离级别

  - `READ UNCOMMITTED`：未提交读。
  - `READ COMMITTED`：已提交读。
  - `REPEATABLE READ`：可重复读。
  - `SERIALIZABLE`：可串行化。
  - `READ UNCOMMITTED`隔离级别下，可能发生`脏读`、`不可重复读`和`幻读`问题。
  - `READ COMMITTED`隔离级别下，可能发生`不可重复读`和`幻读`问题，但是不可以发生`脏读`问题。
  - `REPEATABLE READ`隔离级别下，可能发生`幻读`问题，但是不可以发生`脏读`和`不可重复读`的问题。
  - `SERIALIZABLE`隔离级别下，各种问题都不可以发生。

### 如何设置事务的隔离级别

```mysql
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL level;

level: {
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
}

# e.g.
SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE; #  全局范围影响

SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; # 会话范围影响
```

### MVCC

- `MVCC`（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用`READ COMMITTD`、`REPEATABLE READ`这两种隔离级别的事务在执行普通的`SELECT`操作时访问记录的版本链的过程，这样子可以使不同事务的`读-写`、`写-读`操作并发执行，从而提升系统性能。

- 版本链

  - `InnoDB`存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列
    - `trx_id`：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的`事务id`赋值给`trx_id`隐藏列。
    - `roll_pointer`：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到`undo日志`中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。
  - 记录每次更新后，都会将旧值放到一条`undo日志`中，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个链表，我们把这个链表称之为`版本链`，
  - 版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的`事务id`

- ReadView

  - undolog存储这历史版本的数据，ReadView根据隔离级别选择读取哪个版本的数据

  - `ReadView`中主要包含4个比较重要的内容：

    - `m_ids`：表示在生成`ReadView`时当前系统中活跃的读写事务的`事务id`列表。
    - `min_trx_id`：表示在生成`ReadView`时当前系统中活跃的读写事务中最小的`事务id`，也就是`m_ids`中的最小值。
    - `max_trx_id`：表示生成`ReadView`时系统中应该分配给下一个事务的`id`值。
    - `creator_trx_id`：表示生成该`ReadView`的事务的`事务id`。

  - #### READ COMMITTED —— 每次读取数据前都生成一个ReadView

  - #### REPEATABLE READ —— 在第一次读取数据时生成一个ReadView

### 锁

- 针对`写-写`情况：即并发事务相继对相同的记录做出改动。

- 多个未提交事务相继对一条记录做改动时，需要让它们排队执行，这个排队的过程其实是通过`锁`来实现的。

  - 不加锁

  意思就是不需要在内存中生成对应的`锁结构`，可以直接执行操作。

  - 获取锁成功，或者加锁成功

  意思就是在内存中生成了对应的`锁结构`，而且锁结构的`is_waiting`属性为`false`，也就是事务可以继续执行操作。

  - 获取锁失败，或者加锁失败，或者没有获取到锁

  意思就是在内存中生成了对应的`锁结构`，不过锁结构的`is_waiting`属性为`true`，也就是事务需要等待，不可以继续执行操作。

- 解决`脏读`、`不可重复读`、`幻读`这些问题呢有两种可选的解决方案：

  1. 读操作利用多版本并发控制（`MVCC`），写操作进行`加锁`。
     - 生成`ReadView`的那个时刻做了一次快照，查询语句只能读到在生成`ReadView`之前已提交事务所做的更改, 采用`MVCC`时，`读-写`操作并不冲突。
     - 写-写`情况加锁排队执行。
  2. 读、写操作都采用`加锁`的方式
     - 例如银行存款的事务，读写均采用加锁方式

- 总结：采用`MVCC`方式的话，`读-写`操作彼此并不冲突，性能更高，采用`加锁`方式的话，`读-写`操作彼此需要排队执行，影响性能。

### 一致性读

- 事务利用`MVCC`进行的读取操作称之为`一致性读`，或者`一致性无锁读`，有的地方也称之为`快照读`。

### 锁定读

- ### 共享锁和独占锁

  - `共享锁`，英文名：`Shared Locks`，简称`S锁`。在事务要读取一条记录时，需要先获取该记录的`S锁`。

  - `独占锁`，也常称`排他锁`，英文名：`Exclusive Locks`，简称`X锁`。在事务要改动一条记录时，需要先获取该记录的`X锁`。

  - `S锁`和`X锁`的兼容性

    - 如果事务`T2`想要再获取一个记录的`S锁`，那么事务`T2`也会获得该锁，也就意味着事务`T1`和`T2`在该记录上同时持有`S锁`。
    - 如果事务`T2`想要再获取一个记录的`X锁`，那么此操作会被阻塞，直到事务`T1`提交之后将`S锁`释放掉。

    - 如果事务`T1`首先获取了一条记录的`X锁`之后，那么不管事务`T2`接着想获取该记录的`S锁`还是`X锁`都会被阻塞，直到事务`T1`提交。

  - 当前读：每次读取的都是当前最新的数据，但是读的时候不允许写，写的时候也不允许读。可以通过加锁实现。

  - 锁定读语句

    ```
    SELECT ... LOCK IN SHARE MODE; # S锁
    
    SELECT ... FOR UPDATE; # X锁
    ```

### 写操作

- DELETE
  - 对一条记录做`DELETE`操作的过程其实是先在`B+`树中定位到这条记录的位置，然后获取一下这条记录的`X锁`，然后再执行`delete mark`操作。我们也可以把这个定位待删除记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。
- UPDATE
  - 如果未修改该记录的键值并且被更新的列占用的存储空间在修改前后未发生变化，则先在`B+`树中定位到这条记录的位置，然后再获取一下记录的`X锁`，最后在原记录的位置进行修改操作。其实我们也可以把这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`。
  - 如果未修改该记录的键值并且至少有一个被更新的列占用的存储空间在修改前后发生变化，则先在`B+`树中定位到这条记录的位置，然后获取一下记录的`X锁`，将该记录彻底删除掉（就是把记录彻底移入垃圾链表），最后再插入一条新记录。这个定位待修改记录在`B+`树中位置的过程看成是一个获取`X锁`的`锁定读`，新插入的记录由`INSERT`操作提供的`隐式锁`进行保护。
  - 如果修改了该记录的键值，则相当于在原记录上做`DELETE`操作之后再来一次`INSERT`操作，加锁操作就需要按照`DELETE`和`INSERT`的规则进行了。
- INSERT
  - 一般情况下，新插入一条记录的操作并不加锁, `INSERT`操作提供的`隐式锁`进行保护。

### 多粒度锁

- 分为行锁和表锁
- 意向锁
  - 意向共享锁，英文名：`Intention Shared Lock`，简称`IS锁`。当事务准备在某条记录上加`S锁`时，需要先在表级别加一个`IS锁`。
  - 意向独占锁，英文名：`Intention Exclusive Lock`，简称`IX锁`。当事务准备在某条记录上加`X锁`时，需要先在表级别加一个`IX锁`。
  - IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁。

### InnoDB行级锁

- InnoDB锁是借助聚簇索引实现的

- 记录锁

  - 锁定了某个指定记录的锁

  - `记录锁`也有`S锁`和`X锁`之分

  - 如果搜索没有命中会转变为间隙锁

  - ```mysql
    SELECT * FROM table WHERE id = 31 FOR UPDATE
    ```

- 间隙锁 gap locks 

  - `gap锁`的提出是为了防止插入幻影记录而提出的

  - 对一条记录加了`gap锁`,不会限制其他事务对这条记录加`记录锁`或者继续加`gap锁`

  - ```mysql
    SELECT * FROM TABLE WHERE id BETWEEN 10 AND 20 FOR UPDATE
    ```

  - 如果表中没有10 或者20，回向左右寻找相邻记录，或者使用页中的最大最小记录

  - 左开右开

  - 多事务同时使用间隙锁且存在交集，可能导致死锁。

  - 在可重复读的级别下打开

- 临键锁

  - `next-key锁`的本质就是一个`正经记录锁`和一个`gap锁`的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的`间隙`。
  - 左开右闭

- 插入意向锁

  - 插入一条记录时需要判断一下插入位置是不是被别的事务加了所谓的`gap锁`
  - 有事务想在某个`间隙`中插入新记录，但是现在在等待时生成一个`插入意向锁`

### 乐观锁&悲观锁

- 乐观锁

  - 在修改数据时才检测数据是否先被修改， 类似CAS

  -  ```mysql
     SELECT * FROM table WHERE id = 9; # 获取a的值为1
     
     UPDATE table SET a = 3 WHERE id = 9 AND a = 1; # 修改时检测a是否有被修改
     ```

  - 适用于读多写少场景

  - 性能较好

- 悲观锁

  - 处理数据时直接加锁

  - ```mysql
    SELECT * FROM table WHERE id = 9 FOR UPDATE; # 直接加锁保护
    
    UPDATE table SET a = 3 WHERE id = 9 AND a = 1;
    ```

  - 一致性更好

